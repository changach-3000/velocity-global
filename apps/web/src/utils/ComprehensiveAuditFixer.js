
import pb from '@/lib/pocketbaseClient';

/**
 * Runs comprehensive fixes on the audited courses.
 * @param {Object} auditReport - The report generated by the audit engine.
 * @param {Function} onProgress - Callback for overall progress (msg, percentage).
 * @param {Function} onCourseUpdate - Callback for individual course updates (courseId, status, logEntry).
 * @returns {Promise<Object>} - The final fix report.
 */
export const runComprehensiveFix = async (auditReport, onProgress, onCourseUpdate) => {
  const report = {
    fixedItems: [],
    errors: [],
    logs: []
  };

  const log = (msg, type = 'info', courseId = null) => {
    const entry = { timestamp: new Date().toISOString(), message: msg, type };
    report.logs.push(entry);
    console.log(`[AuditFixer] ${msg}`);
    if (courseId && onCourseUpdate) {
      onCourseUpdate(courseId, null, entry);
    }
  };

  // Filter courses that actually need work
  const coursesToFix = auditReport.courses.filter(c => c.completionPercentage < 100);
  
  if (coursesToFix.length === 0) {
    log("No courses require fixing.", 'success');
    return report;
  }

  let processed = 0;
  const total = coursesToFix.length;

  for (const course of coursesToFix) {
    const courseId = course.id;
    if (onProgress) onProgress(`Processing ${course.name}...`, Math.floor((processed / total) * 100));
    if (onCourseUpdate) onCourseUpdate(courseId, 'fixing', { message: 'Starting fix process...', type: 'info' });

    let courseHasError = false;

    try {
      // --- 1. Fix Badges ---
      if (!course.hasBadges) {
        log(`Creating missing badge for course: ${course.name}`, 'info', courseId);
        try {
          await pb.collection('badges').create({
            name: `${course.name} Completion Badge`,
            description: `Awarded for completing ${course.name}`,
            course_id: courseId,
            icon_url: 'https://via.placeholder.com/150',
            competency_level: 'Intermediate',
            points: 100
          }, { $autoCancel: false });
          
          report.fixedItems.push(`Created badge for ${course.name}`);
          log(`Successfully created badge.`, 'success', courseId);
        } catch (err) {
          const errorMsg = `Failed to create badge: ${err.message}`;
          log(errorMsg, 'error', courseId);
          report.errors.push(errorMsg);
          courseHasError = true;
        }
      }

      // --- 2. Fix Lessons ---
      if (course.lessons && course.lessons.length > 0) {
        for (const lessonReport of course.lessons) {
          const lessonId = lessonReport.id;
          const lessonTitle = lessonReport.title || 'Untitled Lesson';

          // Fix Quiz
          if (!lessonReport.hasQuiz) {
            log(`Creating missing quiz for lesson: ${lessonTitle}`, 'info', courseId);
            try {
              // Validate required fields
              if (!lessonId) throw new Error("Missing lesson ID for quiz creation");

              const quiz = await pb.collection('quizzes').create({
                lesson_id: lessonId,
                title: `${lessonTitle} Quiz`,
                passing_score: 70
              }, { $autoCancel: false });
              
              // Create dummy questions
              const questionsToCreate = [
                { q: "What is the main concept of this lesson?", a: "The core topic discussed." },
                { q: "Which of the following is true?", a: "This statement is correct." },
                { q: "Why is this topic important?", a: "It is fundamental to the subject." }
              ];

              for (let i = 0; i < questionsToCreate.length; i++) {
                await pb.collection('quiz_questions').create({
                  quiz_id: quiz.id,
                  question_text: questionsToCreate[i].q,
                  question_type: 'multiple_choice',
                  options: JSON.stringify(['Option A', 'Option B', 'Option C', 'Option D']),
                  correct_answer: 'Option A',
                  explanation: questionsToCreate[i].a,
                  order: i + 1
                }, { $autoCancel: false });
              }
              
              report.fixedItems.push(`Created quiz for lesson: ${lessonTitle}`);
              log(`Created quiz with ${questionsToCreate.length} questions.`, 'success', courseId);
            } catch (err) {
              const errorMsg = `Failed to create quiz for ${lessonTitle}: ${err.message}`;
              log(errorMsg, 'error', courseId);
              report.errors.push(errorMsg);
              courseHasError = true;
            }
          }

          // Fix Case Study
          if (!lessonReport.hasCaseStudy) {
            log(`Creating missing case study for lesson: ${lessonTitle}`, 'info', courseId);
            try {
              // Schema uses 'course_module' for lesson link
              await pb.collection('case_studies').create({
                title: `${lessonTitle} Case Study`,
                scenario: `Scenario description for ${lessonTitle}.`,
                course_module: lessonId, 
                difficulty_level: 'Intermediate'
              }, { $autoCancel: false });
              
              report.fixedItems.push(`Created case study for lesson: ${lessonTitle}`);
              log(`Created case study.`, 'success', courseId);
            } catch (err) {
              const errorMsg = `Failed to create case study for ${lessonTitle}: ${err.message}`;
              log(errorMsg, 'error', courseId);
              report.errors.push(errorMsg);
              courseHasError = true;
            }
          }

          // Fix Resources
          if (lessonReport.resourceCount === 0) {
            log(`Creating missing resource for lesson: ${lessonTitle}`, 'info', courseId);
            try {
              await pb.collection('lesson_resources').create({
                lesson_id: lessonId,
                resource_name: `${lessonTitle} Guide`,
                resource_type: 'guide',
                description: 'Auto-generated study resource.'
              }, { $autoCancel: false });
              
              report.fixedItems.push(`Created resource for lesson: ${lessonTitle}`);
              log(`Created resource.`, 'success', courseId);
            } catch (err) {
              const errorMsg = `Failed to create resource for ${lessonTitle}: ${err.message}`;
              log(errorMsg, 'error', courseId);
              report.errors.push(errorMsg);
              courseHasError = true;
            }
          }
        }
      } else {
        log(`Course has no lessons to fix components for.`, 'warning', courseId);
      }

      // --- 3. Fix Progress Tracking ---
      if (!course.hasProgressTracking && course.lessons.length > 0) {
        log(`Initializing progress tracking...`, 'info', courseId);
        try {
          const userId = pb.authStore.model?.id;
          if (!userId) {
            throw new Error("User not authenticated. Cannot create enrollment.");
          }

          // Check existing enrollment
          const enrollments = await pb.collection('enrollments').getList(1, 1, {
            filter: `student_id="${userId}" && course_id="${courseId}"`,
            $autoCancel: false
          });
          
          let enrollmentId;
          if (enrollments.totalItems > 0) {
            enrollmentId = enrollments.items[0].id;
            log(`Found existing enrollment.`, 'info', courseId);
          } else {
            const enrollment = await pb.collection('enrollments').create({
              student_id: userId,
              course_id: courseId,
              progress_percentage: 0
            }, { $autoCancel: false });
            enrollmentId = enrollment.id;
            log(`Created new enrollment.`, 'success', courseId);
          }

          // Create lesson progress for first lesson
          await pb.collection('lesson_progress').create({
            enrollment_id: enrollmentId,
            lesson_id: course.lessons[0].id,
            completed: false,
            time_spent: 0
          }, { $autoCancel: false });
          
          report.fixedItems.push(`Initialized progress tracking for ${course.name}`);
          log(`Initialized lesson progress.`, 'success', courseId);
        } catch (err) {
          const errorMsg = `Failed to init progress: ${err.message}`;
          log(errorMsg, 'error', courseId);
          report.errors.push(errorMsg);
          courseHasError = true;
        }
      }

      // Final status update for course
      if (courseHasError) {
        if (onCourseUpdate) onCourseUpdate(courseId, 'error', { message: 'Completed with errors.', type: 'error' });
      } else {
        if (onCourseUpdate) onCourseUpdate(courseId, 'success', { message: 'All fixes applied successfully.', type: 'success' });
      }

    } catch (err) {
      // Catch-all for unexpected course-level errors
      const errorMsg = `Critical error processing course ${course.name}: ${err.message}`;
      log(errorMsg, 'error', courseId);
      report.errors.push(errorMsg);
      if (onCourseUpdate) onCourseUpdate(courseId, 'error', { message: 'Critical failure.', type: 'error' });
    }
    
    processed++;
  }

  if (onProgress) onProgress('Fix process completed.', 100);
  return report;
};
